# Summary

# Предметы:



65. Чем отличаются методы `std::vector` `push_back` и `emplace_back`?  
        vector.push_back(T&&) совершит перемещение и копирование, а vector.emplace_back(T&&) создаст объект на месте без лишнего копирования. 



66. Ссылки на какие объекты уместно возвращать из функции?  
67. Что такое `std::move` (вариант, принимающий один аргумент) и зачем она нужна?  
68. * Что такое `std::forward` и зачем она нужна?  
69. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(int n) { return n; } auto x = f(101);`?  
70. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(T x) { return x; } auto y = f(101);`?  
71. Что произойдёт в `T x; x = T();`?  
        struct T {
            T() {
                std::cout << "default" << std::endl;
            }

            T& operator=(T&&) {
                std::cout << "moved assigment" << std::endl;
                return *this;
            }   
        };

        int main() {
            T x;
            x = T();
        }

        output: 
        default
        default
        moved assigment

        Что произошло: T t - вызов пустого конструктора класса T (Note: в С++ огромное множество способов иницализировать переменную, и это не объявление переменной, а именно ее инициализация и определние с помощью умолчательного конструктора от 0 аргументов, в отличии от примитивных типов, где данная конструкция имеет другой смысл). х = Т() - вызов пустого конструктора класса Т и создание rvalue значения T, затем вызов operator= класса Т от T&&.

72. Корректно ли выражение `f(x.get_value(), std::move(x))`? 
        После того, как был использован std::move(х) мы утверждаем, что в дальнейшем х мы использовать не будем, соответсвенно его можно переместить. Соотвественно если мы будем использовать х после std::move, то у нас UB. Исходя из этого, нам важно чтобы x.get_value() вызвался раньше чем std::move(x), но стнадарт С++ не гарантирует порядок исполнения аргументов при передаче функции(и на парвктике действительно разные компиляторы в разном порядке вызывают аргументы). Соотвественно данное выражение не является корректным.

73. Какие операции над объектами типа `T` будут вызваны в коде `void f(std::vector<T> & v) { v.resize(100); }` и сколько раз?
        
74. Что будет в `class X : public Y { public: void f(); }`, если класс `Y` уже содержит метод `void f()`?  




- [About & Links](./course.md)
