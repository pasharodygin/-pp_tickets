
## 13. `nullptr` и его использование

[`nullptr`](https://en.cppreference.com/w/cpp/language/nullptr) - специальное слово, литерал для указателей, имеет тип `nullptr_t`, который неявно может быть преобразован в указатель любого типа. В C и до C++11 использовали `NULL`, который ну как бы это, `#define NULL 0` (ну или `(void*)0)...`. Так как сейчас у нас есть отдельный тип для такого, то все стало безопаснее, отпадают проблемы с неоднозначной перегрузкой.

Можно явно обрабатывать в `if`, например, что указатель нулевой или нет, что активно используется и используется для перегрузки. Никто нам не мешает принимать `nullptr_t` (хоть у этого типа и одно значение).

## 14. `friend` и его использование

_Краткий ответ_

>Нужно, чтобы другой класс либо внешняя для класса функция имела доступ к приватным полям нашего класса когда вам это необходимо.



Данное [ключевое слово](https://en.cppreference.com/w/cpp/language/friend) может использоваться в двух случаях:

1. **friend функции**

    ```cpp
    class MyClass {
    private:
        int value;

    public:
        MyClass(int v) : value(v) {}

        // Объявляем функцию как дружественную
        friend void printValue(const MyClass& obj);
    };

    // Определение дружественной функции
    void printValue(const MyClass& obj) {
        std::cout << "Value: " << obj.value << std::endl; // Доступ к private member
    }

    int main() {
        MyClass myObj(42);
        printValue(myObj); // Вывод: Value: 42
        return 0;
    }
    ```

   Такие функции могут иметь доступ к внутренним полям класса, хотя на самом деле внешние. Плюс для таких функций запрещено неявное приведение типов, что может быть активно использовано. Важно: функции внешиние - не являются методами класса.

2. **friend классы**

    ```cpp
    class ClassB; // Предварительное объявление

    class ClassA {
    private:
        int valueA;

    public:
        ClassA(int v) : valueA(v) {}

        // Объявляем ClassB как дружественный
        friend class ClassB;
    };

    class ClassB {
    public:
        void showValueA(const ClassA& obj) {
            std::cout << "Value from ClassA: " << obj.valueA << std::endl; // Доступ к private member
        }
    };

    int main() {
        ClassA a(100);
        ClassB b;
        b.showValueA(a); // Вывод: Value from ClassA: 100
        return 0;
    }
    ```

   Тут идея схожая: класс-друг может сувать свой нос в наши приватные поля и вообще что мы все свои. Такое используется, например, когда у тебя есть дерево поиска, нужно написать итератор, и там эти два класса друг - другу друзья. 
   Важно понимать, что friend классы не наследуются.

   Важно отметить, что `friend` нарушает ООП, а именно инкапсуляцию. Так что использование его по мере необходимости и связности концепций.

## 15. `explicit` и его использование

_Краткий ответ_

> Данное [ключевое слово](https://en.cppreference.com/w/cpp/language/explicit) служит для запрета неявных преобразований типов

```cpp
class MyClass {
public:
    explicit MyClass(int value) {
        std::cout << "Constructor called with value: " << value << std::endl;
    }

    explicit operator int() { return 0; }
};

void func(MyClass obj) {
    // Делаем что-то с obj
}

int main() {
    MyClass arg(10);
    func(arg); // Ok
    func(10); // Error: Неявное преобразование int в MyClass
    int m = static_cast<int>(arg) // Ok
    int n = arg // Error: неявное преобразование MyClass в int 
    return 0;
}
```

Итого, данное ключевое слово служит для большей безопасности в работе с типами, если вы не хотите всяческих неявных преобразований или не хотите возможной путаницы при конструкторах, например от одного аргумента. 
Также оно может быть использовано в [операторах преобразований](https://en.cppreference.com/w/cpp/language/cast_operator) для запрета неявных преобразований нашего класса в другой класс.

## 16. `inline` и его использование

_Краткий ответ_

>Данное [ключевое слово](https://en.cppreference.com/w/cpp/language/inline) формально нужно, чтобы показать линковщику, что данная функция или переменная может быть определена множество раз в разных еденицах трансляции и определена одинаково (см. 56 билет: [ODR](./Паша.md#56-что-такое-odr)).

Порой накладные расходы на вызов функции сильно выше, чем время исполнения самой функции. И было бы эффективнее вставить в момент ее вызова непосредственно ее определение (например функции типа `size() { return size; }`). 

В целом, если вы создаете класс и пишете данную функцию, и определили ее в хедере, то за вас она автоматически станет inline, и данное ключевое слово писать не требуется.

Также delete, constexpr и consteval функции неявно являются inline функциями.

Что касается переменных, определять их в хедерах можно только если они inline (еще можно использовать [`constexpr`](https://en.cppreference.com/w/cpp/language/constexpr)), тут придется явно указать это слово, так как в противном случае нарушим ODR и ошибка линковки.

Что по поводу производительности: важно отметить, что компилятор - не дурак; то что вы сказали ему, что данную функцию можно встроить вовсе ему не указ. Он сам решает повысит эта вставка производительность или нет. Однако есть некоторые пределы, например количество строчек функции, при которых компилятор даже не будет думать о вставке. При использовании inline это количество увеличивается, но не более. Компилятору не указ даже `__forceinline`, так что мысли о применении данной эвристики лучше оставить компилятору.
