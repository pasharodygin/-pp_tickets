# Summary

# Предметы:

- [About & Links](./course.md)

# Билеты 1-16

## 1. Разница между указателями и ссылками ?
Разница ссыллок и указателей:
- Указатель может принимать значение nullptr
- Указатель является объектом (существует арифметика указателей)
- Ссылки не изменяемы и не обладает квалификатором `const`
- Ссылки Синтаксически работают как обычные переменные

## 2. Конструктор по-умолчанию, типы конструкторов
Конструктор — это специальная не статическая функция-элемент класса, 
которая используется для инициализации объектов своего классового типа.
- Имя функции совпадает с именем класса.
-  При создании объекта класса всегда вызывается один конструктор.
- Конструктор нельзя вызвать явно.
-  У класса может быть произвольное число конструкторов (в том числе ноль).
### Примеры иницилизации
- По умолчанию
```cpp
struct S{
    S();
    S(int);
    ~S();
}
```
- Список инициализации
```cpp
struct S {
    S(int x) : a(x), b(a * 2) {}  // Список инициализации
    int a;
    int b = 10;  // a:= x; b:= 2 * a или если b  не указано b:= 10;
};
```
В C++ для наследования конструкторов базового класса нужно использовать директиву `using A::A`.
```cpp
struct A {
  A(int, double, char);
 };
 struct B : A {};

 struct C : A {
    using A::A;
 };
 int main() {
  B b(10, 0.5, 'a');   // error
  C c(10, 0.5, '\n');  // OK
 }
 ```

 ## 3. Типы размещения, смысл и разница между ними
 В C++ объекты могут размещаться в разных областях памяти, что влияет на их время жизни, производительность и управление ресурсами.
 ### Автоматический
 Размещается в стеке вызовов и работает очень быстро
 Область видимости: до выхода из области
 Пример
```cpp
void foo() {
    int x = 10;          // Автоматическая переменная
    std::string s = "Hi"; // Объект на стеке
} // x и s уничтожаются здесь
```
### Динамический
Размещается в куче и работает медленее автоматической
Время жизни: пока не вызван delete
```cpp
int* p = new int(42);    // Выделение памяти в куче
std::string* s = new std::string("Hello");

delete p;                // Освобождение памяти
delete s;
```
 ### Статический
 Статическая память, медленнее стека
 Время жизни: вся программа
 ```cpp
 int global = 100;         // Глобальная переменная

void foo() {
    static int x = 0;     // Статическая локальная переменная
    x++;
}
 ```
 ### Thread-local
 Память уникальная для каждого потока и живет до конца жизни потока
 ```cpp
 thread_local int x = 0; // У каждого потока своя копия x
 ```


