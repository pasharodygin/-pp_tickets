
# Билеты 44 - 54

## 44. Чем отличается `new int(10)` от `new int[10]`?  
[operator new](https://en.cppreference.com/w/cpp/memory/new/operator_new) **!пытается!**** аллоцировать какую-то память в динамической куче (в оперативке). Первый аллоцирует число `int{10}` и возвращает указатель на этот элемент, второй вариант сложнее, сначала он записывает размер массива, который вы пытаетесь разместить, затем все элементы этого массива поочередно. Зачем это нужно: выделяя память на куче с помощью `new`, вы берете ответственность за ее освобождение, так как [время жизни](https://en.cppreference.com/w/cpp/language/lifetime) этого объекта контролируется вами. Соответственно существует два способа освободить эту память (в рамках C++), а именно `operator delete` и `operator delete[]`, соответственно каждый из них нужно вызывать в соответствии с тем, какой оператор вы использовали для выделения памяти. Так как оператор `delete` освобождает указанную ему по указателю память и больше ничего, а `delete[]` ищет тот самый размер до указателя, который мы туда должны были записать оператором `new[]`, и только по нему далее удаляет столько памяти, сколько нужно. 

### Вывод:
Для `new` используйте `delete`, для `new[]` используйте `delete[]`, иначе пупа получит за лупу.

## 45. Можно ли делать `delete ptr;` после `auto ptr = new T[5];` и почему?
**Смотри выше!** Если так сделать, то это UB. Такой код конечно может запуститься и ничего страшного не произойдет, ведь после завершения программы вся память, которую она выделила, очищается автоматически, но в целом такое поведение вызывает утечку памяти, которая плоха тем, что бывает трудно обнаружима и может влечь внезапные ошибки в рандомный момент.  
Offtop: В том числе для решения такой проблемы придумали [умные указатели](https://en.cppreference.com/book/intro/smart_pointers).

## 46. Что такое placement new (размещающее new)?  
Аналогично обычному оператору new позволяет выделять объект в куске памяти, но на этот раз не только на куче, но и на любом буфере, в том числе статическом.

```cpp
int main() {
    void* buffer = ...;
    T* obj = new (buffer) T();
    obj->~T();
    return 0;
}
```

Память которую мы используем для буфера должна быть достаточно неинициализированной памяти для размещения объектов; также она должна быть выровнена. Стоит заметить, что мы должны самостоятельно вызывать деструктор объекта, который выделили, так как он не будет вызван автоматически из-за специфики хранения. Бывает полезно, если мы не хотим много раз ходить к ядру и просить память или хотите использовать статическую память для данных манипуляций, что может отразиться на производительности.

## 47. Как обеспечить корректное удаление объекта, созданного при помощи размещающего new?  

**Смотри выше!** Вырезка из [базы](https://en.cppreference.com/w/cpp/language/new): You must **manually** call the object's destructor if its side effects are depended by the program.

## 48. Undefined, unspecified and implementation-defined behavior
В сущности эти три понятия характеризуют поведение программы в случаях, когда стандарт языка не дает прямого ответа. Примеры соответствующих поведений описаны в ссылках в названии:
1. [Undefined behavior](https://en.cppreference.com/w/cpp/language/ub)  
   Стандарт не несет ответственности за то, что произойдет; произойти может **все что угодно**. Чаще всего конечно происходит далеко не все что угодно и никто форматировать ваш диск не будет; но в сущности поведение программы в данных ситуациях бывает крайне непредсказуемым.
   
2. [Unspecified behavior](https://en.wikipedia.org/wiki/Unspecified_behavior)  
   Ситуация когда компилятор может выбирать что делать; так как стандарт определил возможные варианты но не заставил указать как именно — например передача аргументов в функцию когда порядок вычисления аргументов не установлен стандартом; однако все аргументы должны быть вычислены; соответственно разные компиляторы выбирают разные способы.
   
3. [Implementation-defined behavior](https://www.youtube.com/watch?v=dQw4w9WgXcQ)  
   Здесь в отличие от пункта выше компилятор должен четко указать как именно он реализует это поведение; разработчики могут реализовывать платформопереносимые программы.

## 49. Что такое наблюдаемое поведение программы (observable behaviour), зачем нужно это понятие?  
Итак, в предыдущем билете затрагивались классы поведения программ; соответственно если программа не находится ни в одном из этих классов она является программой с [наблюдаемым поведением](https://en.cppreference.com/w/cpp/language/as_if) (так в стандарте определено это понятие). Основной смысл и польза состоит в том что выполнение программы достаточно корректно и предсказуемо; мы можем анализировать ее выполнение с помощью других программ что дает нам большие возможности для анализа как для разработчика.

## 50. Что такое `this`? Можно ли делать присваивание в `this` и почему?  
[this](https://en.cppreference.com/w/cpp/language/this) — это **константный** указатель на экземпляр класса метод которого был вызван. Так как указатель константный то присвоить ему другой объект невозможно; но можно получать доступ ко всем его методам и полям как у указателя.

## 51. Можно ли делать `delete this`, почему?  
Это выражение вполне возможно использовать; если объект был выделен с помощью `new`, оно будет освобождать текущий экземпляр `this`. После выполнения этой операции любые обращения будут недействительными. Такое даже используется, например в [shared_ptr](https://en.cppreference.com/w/cpp/memory/shared_ptr).

## 52. Что такое явное/неявное преобразование типов?  

## 53. Какие есть варианты явного приведения типов (cast) в C++ и чем отличаются?  

## 54. Что такое макросы? В чем отличия от функций (для макросов в духе `#define MAX(a, b)`)?
