## Список билетов для коллоквиума по C++

1. Разница между указателями и ссылками  
2. Конструктор по-умолчанию, типы конструкторов  
3. Типы размещения, смысл и разница между ними  
4. В каком порядке происходит инициализация объектов со статическим размещением в программе?  
5. Что такое объект в C++?  
6. Этапы жизни объекта  
7. `const` и его использование  
8. `static` и его использование  
9. * `virtual` и его использование  
10. * `override` и его использование  
11. * `template` и его использование  
12. `void` и его использование  
13. `nullptr` и его использование  
14. `friend` и его использование  
15. `explicit` и его использование  
16. `inline` и его использование  
17. Какие методы класса могут быть автоматически сгенерированы компилятором?  
18. Виды передачи параметров в функцию  
19. Как передать в функцию строковый параметр - различные варианты  
20. Как вернуть результат(ы) из функции - различные варианты  
21. Каков порядок вычисления выражений, передаваемых в качестве аргументов при вызове функции?  
22. Пост- и пре- инкремент, в чем разница  
23. * Что такое абстрактный класс и в чём его отличия от обычных?  
24. Тернарный оператор - что это, в чём отличие от ветвления  
25. В чём отличие & от && ?  
26. В чём отличие = и == ?  
27. Переопределение стандартных операторов для пользовательских классов: 2 подхода  
28. В чём отличие определения от объявления?  
29. Что такое перемещение (move), для чего и как его использовать?  
30. Какие есть типы циклов в C++ и в чем разница между ними?  
31. Зачем нужны .h файлы и как это реализуется?  
32. Что является единицей трансляции в C++?  
33. Что такое объектный файл?  
34. Чем инициализируются переменные типа bool по умолчанию?  
35. Какие варианты приведения типов по иерархии наследования существуют и чем отличаются?  
36. В чем разница между enum и enum class, зачем нужны последние?  
37. Есть ли разница между структурой struct и классом class?  
38. Какие есть спецификаторы прав доступа в C++ и в чем отличие между ними?  
39. Что такое конструктор и когда он вызывается?  
40. Что такое деструктор и когда он вызывается?  
41. Можно ли явно вызвать конструктор?  
42. Можно ли явно вызвать деструктор?  
43. В чем разница между оператором присваивания и конструктором копирования?  
44. Чем отличается `new int(10)` от `new int[10]`?  
45. Можно ли делать `delete ptr;` после `auto ptr = new T[5];` и почему?  
46. Что такое placement new (размещающее new)?  
47. Как обеспечить корректное удаление объекта, созданного при помощи размещающего new?  
48. Undefined, unspecified and implementation-defined behavior  
49. Что такое наблюдаемое поведение программы (observable behaviour), зачем нужно это понятие?  
50. Что такое `this`? Можно ли делать присваивание в `this` и почему?  
51. Можно ли делать `delete this`, почему?  
52. Что такое явное/неявное преобразование типов?  
53. Какие есть варианты явного приведения типов (cast) в C++ и чем отличаются?  
54. Что такое макросы? В чем отличия от функций (для макросов в духе `#define MAX(a, b)`) ?  
55. Что делает препроцессор?  
56. Что такое ODR?  
57. В каких случаях допустимо размещать определение функции в заголовочном файле, а в каких - нет?  
58. Что такое предварительное объявление (forward declaration) и для каких элементов языка это актуально?  
59. Когда начнётся и когда закончится время жизни объекта с именем `a`: `void f(X a) {}`?  
60. Когда начнётся и когда закончится время жизни объекта доступного по указателю `pa`: `void f() { auto pa = new X; }`?  
61. В каком порядке будут созданы, а в каком разрушены объекты с именами `a` и `b`: `void f() { X a; { Y b; } }`?  
62. Какие подобъекты будут присутствовать в объекте класса `X`: `struct X : Y, Z { W w; V v; };`, каков порядок их создания и разрушения?  
63. Что такое временный объект и чем ограничено его время жизни?  
64. Чем отличается инициализация по умолчанию для базовых и пользовательских типов (классов)?  
[55. Что делает препроцессор?](./Паша.md#55-Что-делает-препроцессор)  
[56. Что такое ODR?](./Паша.md#56-Что-такое-odr)  
[57. В каких случаях допустимо размещать определение функции в заголовочном файле, а в каких - нет?](./Паша.md#57-В-каких-случаях-допустимо-размещать-определение-функции-в-заголовочном-файле-а-в-каких---нет)  
[58. Что такое предварительное объявление (forward declaration) и для каких элементов языка это актуально?](./Паша.md#58-Что-такое-предварительное-объявление-forward-declaration-и-для-каких-элементов-языка-это-актуально)  
[59. Когда начнётся и когда закончится время жизни объекта с именем a: void f(X a) {}?](./Паша.md#59-Когда-начнётся-и-когда-закончится-время-жизни-объекта-с-именем-a-void-fx-a)  
[60. Когда начнётся и когда закончится время жизни объекта доступного по указателю pa: void f() { auto pa = new X; }?](./Паша.md#60-Когда-начнётся-и-когда-закончится-время-жизни-объекта-доступного-по-указателю-pa-void-f-авто-pa-равно-new-X)  
[61. В каком порядке будут созданы, а в каком разрушены объекты с именами a и b: void f() { X a; { Y b; } }?](./Паша.md#61-В-каком-порядке-будут-созданы-а-в-каком-разрушены-объекты-с-именами-a-и-b-void-f-X-a-Y-b)  
[62. Какие подобъекты будут присутствовать в объекте класса X: struct X : Y, Z { W w; V v; };, каков порядок их создания и разрушения?](./Паша.md#62-Какие-подобъекты-будут-присутствовать-в-объекте-класса-X-struct-X-Y-Z-W-w-V-v)  
[63. Что такое временный объект и чем ограничено его время жизни?](./Паша.md#63-Что-такое-временный-объект-и-чем-ограничено-его-время-жизни)  
[64. Чем отличается инициализация по умолчанию для базовых и пользовательских типов (классов)?](./Паша.md#64-Чем-отличается-инициализация-по-умолчанию-для-базовых-и-пользовательских-типов-классов)

65. Чем отличаются методы `std::vector` `push_back` и `emplace_back`?  
66. Ссылки на какие объекты уместно возвращать из функции?  
67. Что такое `std::move` (вариант, принимающий один аргумент) и зачем она нужна?  
68. * Что такое `std::forward` и зачем она нужна?  
69. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(int n) { return n; } auto x = f(101);`?  
70. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(T x) { return x; } auto y = f(101);`?  
71. Что произойдёт в `T x; x = T();`?  
72. Корректно ли выражение `f(x.get_value(), std::move(x))`?  
73. Какие операции над объектами типа `T` будут вызваны в коде `void f(std::vector<T> & v) { v.resize(100); }` и сколько раз?  
74. Что будет в `class X : public Y { public: void f(); }`, если класс `Y` уже содержит метод `void f()`?  
