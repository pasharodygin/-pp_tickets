## Список билетов для коллоквиума по C++

[1. Разница между указателями и ссылками](./Гоша.md#1-Разница-между-указателями-и-ссылками)  
[2. Конструктор по-умолчанию, типы конструкторов](./Гоша.md#2-Конструктор-по-умолчанию-типы-конструкторов)  
[3. Типы размещения, смысл и разница между ними](./Гоша.md#3-Типы-размещения-смысл-и-разница-между-ними)  
[4. В каком порядке происходит инициализация объектов со статическим размещением в программе?](./Гоша.md#4-В-каком-порядке-происходит-инициализация-объектов-со-статическим-размещением-в-программе)  
[5. Что такое объект в C++?](./Гоша.md#5-Что-такое-объект-в-C++)  
[6. Этапы жизни объекта](./Гоша.md#6-Этапы-жизни-объекта)  
[7. `const` и его использование](./Гоша.md#7-const-и-его-использование)  
[8. `static` и его использование](./Гоша.md#8-static-и-его-использование)  
[9. * `virtual` и его использование](./Гоша.md#9-virtual-и-его-использование)  
[10. * `override` и его использование](./Гоша.md#10-override-и-его-использование)  
[11. * `template` и его использование](./Гоша.md#11-template-и-его-использование)  
[12. `void` и его использование](./Гоша.md#12-void-и-его-использование)  
[13. `nullptr` и его использование](./Гоша.md#13-nullptr-и-его-использование)  
[14. `friend` и его использование](./Гоша.md#14-friend-и-его-использование)  
[15. `explicit` и его использование](./Гоша.md#15-explicit-и-его-использование)  
[16. `inline` и его использование](./Гоша.md#16-inline-и-его-использование)  

[17. Какие методы класса могут быть автоматически сгенерированы компилятором?](./Никита.md#17-Какие-методы-класса-могут-быть-автоматически-сгенерированы-компилятором)  
[18. Виды передачи параметров в функцию](./Никита.md#18-Виды-передачи-параметров-в-функцию)  
[19. Как передать в функцию строковый параметр - различные варианты](./Никита.md#19-Как-передать-в-функцию-строковый-параметр---различные-варианты)  
[20. Как вернуть результат(ы) из функции - различные варианты](./Никита.md#20-Как-вернуть-результаты-из-функции---различные-варианты)  
[21. Каков порядок вычисления выражений, передаваемых в качестве аргументов при вызове функции?](./Никита.md#21-Каков-порядок-вычисления-выражений-передаваемых-в-качестве-аргументов-при-вызове-функции)  
[22. Пост- и пре- инкремент, в чем разница](./Никита.md#22-Пост--и-пре--инкремент-в-чем-разница)  
[23. * Что такое абстрактный класс и в чём его отличия от обычных?](./Никита.md#23-Что-такое-абстрактный-класс-и-в-чём-его-отличия-от-обычных)  
[24. Тернарный оператор - что это, в чём отличие от ветвления](./Никита.md#24-Тернарный-оператор---что-это-в-чём-отличие-от-ветвления)  
[25. В чём разница & от && ?](./Никита.md#25-В-чём-разница--от--)  
[26. В чём разница = и == ?](./Никита.md#26-В-чём-разница--и-==-)  
[27. Переопределение стандартных операторов для пользовательских классов: 2 подхода](./Никита.md#27-Переопределение-стандартных-операторов-для-пользовательских-классов-2-подхода)  
[28. В чём разница определения от объявления?](./Никита.md#28-В-чём-разница-определения-от-объявления)  
[29. Что такое перемещение (move), для чего и как его использовать?](./Никита.md#29-Что-такое-перемещение-move-для-чего-и-как-его-использовать)  
[30. Какие есть типы циклов в C++ и в чем разница между ними?](./Никита.md#30-Какие-есть-типы-циклов-в-C++-и-в-чем-разница-между-ними)  
[31. Зачем нужны .h файлы и как это реализуется?](./Никита.md#31-Зачем-нужны-h-файлы-и-как-это-реализуется)  
[32. Что является единицей трансляции в C++?](./Никита.md#32-Что-является-единицей-трансляции-в-C++)  
[33. Что такое объектный файл?](./Никита.md#33-Что-такое-объектный-файл)  

[34. Чем инициализируются переменные типа bool по умолчанию?](./Коля.md#34-Чем-инициализируются-переменные-типа-bool-по-умолчанию)  
[35. Какие варианты приведения типов по иерархии наследования существуют и чем отличаются?](./Коля.md#35-Какие-варианты-приведения-типов-по-иерархии-наследования-существуют-и-чем-отличаются)  
[36. В чем разница между enum и enum class, зачем нужны последние?](./Коля.md#36-В-чем-разница-между-enum-и-enum-class-зачем-нужны-последние)  
[37. Есть ли разница между структурой struct и классом class?](./Коля.md#37-Есть-ли-разница-между-структурой-struct-и-классом-class)  
[38. Какие есть спецификаторы прав доступа в C++ и в чем отличие между ними?](./Коля.md#38-Какие-есть-спецификаторы-прав-доступа-в-C++-и-в-чем-отличие-между-ними)  
[39. Что такое конструктор и когда он вызывается?](./Коля.md#39-Что-такое-конструктор-и-когда-он-вызывается)  
[40. Что такое деструктор и когда он вызывается?](./Коля.md#40-Что-такое-деструктор-и-когда-он-вызывается)  
[41. Можно ли явно вызвать конструктор?](./Коля.md#41-Можно-ли-явно-вызвать-конструктор)  
[42. Можно ли явно вызвать деструктор?](./Коля.md#42-Можно-ли-явно-вызвать-деструктор)  
[43. В чем разница между оператором присваивания и конструктором копирования?](./Коля.md#43-В-чем-разница-между-оператором-присваивания-и-конструктором-копирования)  

[44. Чем отличается `new int(10)` от `new int[10]`?](./Артём.md#44-Чем-отличается-new-int10-от-new-int10)  
[45. Можно ли делать `delete ptr;` после `auto ptr = new T[5];` и почему?](./Артём.md#45-Можно-ли-делать-delete-ptr-после-auto-ptr-равно-new-T5-и-почему)  
[46. Что такое placement new (размещающее new)?](./Артём.md#46-Что-такое-placement-new-размещающее-new)  
[47. Как обеспечить корректное удаление объекта, созданного при помощи размещающего new?](./Артём.md#47-Как-обеспечить-корректное-удаление-объекта-созданного-при-помощи-размещающего-new)  
[48. Undefined, unspecified and implementation-defined behavior](./Артём.md#48-Undefined-unspecified-and-implementation-defined-behavior)  
[49. Что такое наблюдаемое поведение программы (observable behaviour), зачем нужно это понятие?](./Артём.md#49-Что-такое-наблюдаемое-поведение-программы-observable-behaviour-зачем-нужно-это-понятие)  
[50. Что такое `this`? Можно ли делать присваивание в `this` и почему?](./Артём.md#50-Что-такое-this-Можно-ли-делать-присваивание-в-this-и-почему)  
[51. Можно ли делать `delete this`, почему?](./Артём.md#51-Можно-ли-делать-delete-this-почему)  
[52. Что такое явное/неявное преобразование типов?](./Артём.md#52-Что-такое-явное-неявное-преобразование-типов)  
[53. Какие есть варианты явного приведения типов (cast) в C++ и чем отличаются?](./Артём.md#53-Какие-есть-варианты-явного-приведения-типов-cast-в-C++-и-чем-отличаются)  
[54. Что такое макросы? В чем отличия от функций (для макросов в духе `#define MAX(a, b)`) ?](./Артём.md#54-Что-такое-макросы-В-чем-отличия-от-функций-для-макросов-в-духе-define-MAXa-b)  

[55. Что делает препроцессор?](./Паша.md#55-Что-делает-препроцессор)  
[56. Что такое ODR?](./Паша.md#56-Что-такое-odr)  
[57. В каких случаях допустимо размещать определение функции в заголовочном файле, а в каких - нет?](./Паша.md#57-В-каких-случаях-допустимо-размещать-определение-функции-в-заголовочном-файле-а-в-каких---нет)  
[58. Что такое предварительное объявление (forward declaration) и для каких элементов языка это актуально?](./Паша.md#58-Что-такое-предварительное-объявление-forward-declaration-и-для-каких-элементов-языка-это-актуально)  
[59. Когда начнётся и когда закончится время жизни объекта с именем a: void f(X a) {}?](./Паша.md#59-Когда-начнётся-и-когда-закончится-время-жизни-объекта-с-именем-a-void-fx-a)  
[60. Когда начнётся и когда закончится время жизни объекта доступного по указателю pa: void f() { auto pa = new X; }?](./Паша.md#60-Когда-начнётся-и-когда-закончится-время-жизни-объекта-доступного-по-указателю-pa-void-f-авто-pa-равно-new-X)  
[61. В каком порядке будут созданы, а в каком разрушены объекты с именами a и b: void f() { X a; { Y b; } }?](./Паша.md#61-В-каком-порядке-будут-созданы-а-в-каком-разрушены-объекты-с-именами-a-и-b-void-f-X-a-Y-b)  
[62. Какие подобъекты будут присутствовать в объекте класса X: struct X : Y, Z { W w; V v; };, каков порядок их создания и разрушения?](./Паша.md#62-Какие-подобъекты-будут-присутствовать-в-объекте-класса-X-struct-X-Y-Z-W-w-V-v)  
[63. Что такое временный объект и чем ограничено его время жизни?](./Паша.md#63-Что-такое-временный-объект-и-чем-ограничено-его-время-жизни)  
[64. Чем отличается инициализация по умолчанию для базовых и пользовательских типов (классов)?](./Паша.md#64-Чем-отличается-инициализация-по-умолчанию-для-базовых-и-пользовательских-типов-классов)

[65. Чем отличаются методы `std::vector` `push_back` и `emplace_back`](./Марсель.md#65-Чем-отличаются-методы-stdvector-push_back-и-emplace_back)  
[66. Ссылки на какие объекты уместно возвращать из функции?](./Марсель.md#66-Ссылки-на-какие-объекты-уместно-возвращать-из-функции)  
[67. Что такое `std::move` (вариант, принимающий один аргумент) и зачем она нужна?](./Марсель.md#67-Что-такое-stdmove-вариант-принимающий-один-аргумент-и-зачем-она-нужна)  
[68. Что такое `std::forward` и зачем она нужна?](./Марсель.md#68-Что-такое-stdforward-и-зачем-она-нужна)  
[69. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(int n) { return n; } auto x = f(101);`?](./Марсель.md#69-Какие-конструкторы-и-сколько-раз-класса-T-будут-вызваны-T-fint-n-возвратить-n-auto-x-f101)  
[70. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(T x) { return x; } auto y = f(101);`?](./Марсель.md#70-Какие-конструкторы-и-сколько-раз-класса-T-будут-вызваны-T-fTx-возвратить-x-auto-y-f101)  
[71. Что произойдёт в `T x; x = T();`?](./Марсель.md#71-Что-произойдёт-в-T-x-x-T)  
[72. Корректно ли выражение `f(x.get_value(), std::move(x))`?](./Марсель.md#72-Корректно-ли-выражение-fxget_value-stdmovex)  
[73. Какие операции над объектами типа `T` будут вызваны в коде `void f(std::vector<T> & v) { v.resize(100); }` и сколько раз?](./Марсель.md#73-Какие-операции-над-объектами-типа-T-будут-вызваны-в-коде-void-fstdvectorT-v-vresize100)  
[74. Что будет в `class X : public Y { public: void f(); }`, если класс `Y` уже содержит метод `void f()`?](./Марсель.md#74-Что-будет-в-class-X-public-Y-public-void-f-если-класс-Y-уже-содержит-метод-void-f)


1. Разница между указателями и ссылками  
2. Конструктор по-умолчанию, типы конструкторов  
3. Типы размещения, смысл и разница между ними  
4. В каком порядке происходит инициализация объектов со статическим размещением в программе?  
5. Что такое объект в C++?  
6. Этапы жизни объекта  
7. `const` и его использование  
8. `static` и его использование  
9. * `virtual` и его использование  
10. * `override` и его использование  
11. * `template` и его использование  
12. `void` и его использование  
13. `nullptr` и его использование  
14. `friend` и его использование  
15. `explicit` и его использование  
16. `inline` и его использование  
17. Какие методы класса могут быть автоматически сгенерированы компилятором?  
18. Виды передачи параметров в функцию  
19. Как передать в функцию строковый параметр - различные варианты  
20. Как вернуть результат(ы) из функции - различные варианты  
21. Каков порядок вычисления выражений, передаваемых в качестве аргументов при вызове функции?  
22. Пост- и пре- инкремент, в чем разница  
23. * Что такое абстрактный класс и в чём его отличия от обычных?  
24. Тернарный оператор - что это, в чём отличие от ветвления  
25. В чём отличие & от && ?  
26. В чём отличие = и == ?  
27. Переопределение стандартных операторов для пользовательских классов: 2 подхода  
28. В чём отличие определения от объявления?  
29. Что такое перемещение (move), для чего и как его использовать?  
30. Какие есть типы циклов в C++ и в чем разница между ними?  
31. Зачем нужны .h файлы и как это реализуется?  
32. Что является единицей трансляции в C++?  
33. Что такое объектный файл?  
34. Чем инициализируются переменные типа bool по умолчанию?  
35. Какие варианты приведения типов по иерархии наследования существуют и чем отличаются?  
36. В чем разница между enum и enum class, зачем нужны последние?  
37. Есть ли разница между структурой struct и классом class?  
38. Какие есть спецификаторы прав доступа в C++ и в чем отличие между ними?  
39. Что такое конструктор и когда он вызывается?  
40. Что такое деструктор и когда он вызывается?  
41. Можно ли явно вызвать конструктор?  
42. Можно ли явно вызвать деструктор?  
43. В чем разница между оператором присваивания и конструктором копирования?  
44. Чем отличается `new int(10)` от `new int[10]`?  
45. Можно ли делать `delete ptr;` после `auto ptr = new T[5];` и почему?  
46. Что такое placement new (размещающее new)?  
47. Как обеспечить корректное удаление объекта, созданного при помощи размещающего new?  
48. Undefined, unspecified and implementation-defined behavior  
49. Что такое наблюдаемое поведение программы (observable behaviour), зачем нужно это понятие?  
50. Что такое `this`? Можно ли делать присваивание в `this` и почему?  
51. Можно ли делать `delete this`, почему?  
52. Что такое явное/неявное преобразование типов?  
53. Какие есть варианты явного приведения типов (cast) в C++ и чем отличаются?  
54. Что такое макросы? В чем отличия от функций (для макросов в духе `#define MAX(a, b)`) ?   


65. Чем отличаются методы `std::vector` `push_back` и `emplace_back`?  
66. Ссылки на какие объекты уместно возвращать из функции?  
67. Что такое `std::move` (вариант, принимающий один аргумент) и зачем она нужна?  
68. * Что такое `std::forward` и зачем она нужна?  
69. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(int n) { return n; } auto x = f(101);`?  
70. Какие конструкторы (и сколько раз) класса `T` будут вызваны: `T f(T x) { return x; } auto y = f(101);`?  
71. Что произойдёт в `T x; x = T();`?  
72. Корректно ли выражение `f(x.get_value(), std::move(x))`?  
73. Какие операции над объектами типа `T` будут вызваны в коде `void f(std::vector<T> & v) { v.resize(100); }` и сколько раз?  
74. Что будет в `class X : public Y { public: void f(); }`, если класс `Y` уже содержит метод `void f()`?  
