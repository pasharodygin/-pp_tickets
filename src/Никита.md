# Билеты 17-33

## №17 Какие методы класса могут быть автоматически сгенерированы компилятором?
> В C++ компилятор может автоматически сгенерировать специальные методы класса, если они не объявлены явно.

### 1. Конструктор по умолчанию (Default Constructor)
- Генерируется, если нет других пользовательских конструкторов.
- Не генерируется, если:
  - Есть любой пользовательский конструктор.
 - Есть поле без инициализатора, которое нельзя инициализировать по умолчанию (например, ссылка или const-поле без инициализатора).

### 2. Деструктор (Destructor)
- Генерируется автоматически, если не объявлен пользовательский деструктор.
- Обычно объявляется как noexcept (если не выбрасывает исключений).
- Важно: Если класс управляет ресурсами (память, файлы), деструктор нужно определять вручную!

### 3. Копирующий конструктор (Copy Constructor)
- Генерируется, если нет пользовательских (хотя бы одного из списка):
  - Конструктора копирования.
  - Перемещающего конструктора.
  - Перемещающего оператора присваивания.
  - Деструктора.
 - Поведение: Поэлементное копирование всех полей.

### 4. Копирующий оператор присваивания (Copy Assignment Operator)
 - Генерируется при тех же условиях, что и копирующий конструктор.
 - Поведение: Поэлементное присваивание полей.

### 5. Перемещающий конструктор (Move Constructor)
 - Генерируется, если:
   - Нет пользовательских (хотя бы одного из списка):
     - Деструктора.
     - Конструктора копирования.
     - Оператора копирования.
     - Оператора перемещения.
   - Все поля и базовые классы поддерживают перемещение.
 - Поведение: Поэлементное перемещение полей (через std::move).

### 6. Перемещающий оператор присваивания (Move Assignment Operator)
 - Генерируется при тех же условиях, что и перемещающий конструктор.
 - Поведение: Поэлементное перемещение полей.


## №18 Виды передачи параметров в функцию

### 1. Передача по значению (by value)
```cpp
void func(int x) { x = 10; }
```
- Создается копия передаваемого значения
- Изменения внутри функции не влияют на оригинал
- Подходит для простых типов (int, float, char)
- Неэффективно для больших объектов (происходит полное копирование)

### 2. Передача по указателю (by pointer)
```cpp
void func(int* ptr) { *ptr = 10; }
```
- Передается адрес переменной
- Можно изменять оригинальное значение
- Может быть nullptr
- Требует явного разыменования (*) для доступа к значению
- Используется для:
  - Опциональных параметров (может быть nullptr)
  - Массивов в C-стиле
  - Низкоуровневых операций

### 3. Передача по ссылке (by reference)
``` cpp
   void func(int& ref) { ref = 10; }
```
- Работает с оригинальным объектом (псевдоним)
- Не может быть nullptr
- Синтаксически проще указателей (не требует разыменования)
- По умолчанию используется в C++ для модификации объектов

### 4. Передача по константной ссылке (by const reference)

```cpp
void func(const std::string& str) { /* ... */ }
```
- Избегает копирования больших объектов
- Гарантирует, что объект не будет изменен
- Оптимальный выбор для передачи:
  - Строк
  - Векторов
  - Крупных объектов
  - Объектов, которые дорого копировать
### 5. Передача по rvalue-ссылке (by rvalue reference)
```cpp
   void process(std::string&& str) {  // Принимает только rvalue
    // Можно безопасно перемещать ресурсы
    std::string local = std::move(str);
}

process(getString());  // OK - временный объект
process("temporary");  // OK - строковый литерал

std::string s = "test";
process(std::move(s)); // OK - явное преобразование
// process(s);         // Ошибка - s это lvalue
```

- Для временных объектов (rvalues)
- Позволяет эффективно "забирать" ресурсы
- Используется в:
  - Конструкторах перемещения
  - Операторах перемещающего присваивания
  - Функциях, оптимизированных для временных объектов

### 6. Передача по универсальной ссылке (universal reference)
```cpp
template<typename T>
void forwardExample(T&& arg) {
    // Передаёт аргумент дальше с сохранением категории значения
    otherFunction(std::forward<T>(arg));
```

- Работает как с lvalue, так и с rvalue
- Позволяет реализовать perfect forwarding
- Когда используется:
  - Когда функция-обёртка должна передать аргумент в другую функцию без изменения его категории (lvalue/rvalue)
  - В реализациях фабричных функций, конструкторов, делегирующих вызовов

| Тип передачи          | Можно изменить оригинал | Защита от изменений | Нулевые значения | Эффективность для больших объектов  |
|-----------------------|-------------------------|---------------------|------------------|--------------------------------------|
| **По значению**       | ❌ Нет                  | ✅ Да               | ❌ Нет           | ⚠️ Низкая (копирование)             |
| **По указателю**      | ✅ Да                   | ❌ Нет              | ✅ Да            | ✅ Высокая                           |
| **По ссылке**         | ✅ Да                   | ❌ Нет              | ❌ Нет           | ✅ Высокая                           |
| **По const ссылке**   | ❌ Нет                  | ✅ Да               | ❌ Нет           | ✅ Высокая                           |
| **По rvalue-ссылке**  | ✅ Да (перемещение)     | ❌ Нет              | ❌ Нет           | ✅ Максимальная                      |


## №19 Как передать в функцию строковый параметр - различные варианты

> применимы способы из билета №18, также есть еще один

### По string_view с версии C++17
```cpp
// std::string_view используется во многих методах STL
std::string s = "Hello";
s.starts_with("He");  // Метод принимает string_view
```
- Для "доступа без владения" к:
  - std::string
  - C-строкам (const char*)
  - Фрагментам строк (substr)
- Не выделяет память (дешевле const string&)

| Операция          | `std::string` | `std::string_view`           |
|-------------------|---------------|------------------------------|
| Передача параметра | O(n)         | O(1)                         |
| `.substr()`       | O(n)         | O(1)                         |
| `.find()`         | O(n*m)       | O(nm) но быстрее на практике |


## №20 Как вернуть результат(ы) из функции - различные варианты

### 1. Возврат по значению (копирование)
```cpp
std::string getString() { 
    return "Hello"; 
}
```
- Срабатывает copy elision (пропуск копирования)
  - Компилятор может пропускать копирование при возврате значений
  - Обязательно с C++17 для prvalue
- Применимо к любым типам
- Для сложных объектов использует RVO (Return Value Optimization)
  ```cpp
    std::string createString() {
    return std::string("Hello"); // Анонимный временный объект
    }
    ```
  - Оптимизирует возврат анонимных временных объектов (prvalue).
  - Работает даже без флагов оптимизации (гарантировано стандартом C++17).
- NRVO (Named Return Value Optimization)
  ```cpp
    std::string createNamedString() {
    std::string local = "Hello"; // Именованная локальная переменная
    return local; // NRVO применяется здесь
    }
    ```
  - Оптимизирует возврат именованных локальных переменных (lvalue).
  - Не гарантировано стандартом (зависит от компилятора).
  - Требует включённой оптимизации (-O2, /O2).


### 2. Возврат по ссылке/указателю
```cpp
const std::string& getConstRef() {
    static std::string s = "Hello";
    return s; // Возврат ссылки на существующий объект
}
```
- ❗ Опасность: висячие ссылки при возврате локальных объектов
- Используется для:
  - Доступа к элементам контейнеров (std::vector::operator[])
  - Возврата статических/глобальных переменных
#### Ограничение!
```cpp
std::string& badExample() {
    std::string local; // Локальная переменная
    return local; // UB при использовании!
}
```
- Время жизни local:
  - Создаётся при входе в функцию.
  - Уничтожается при выходе из функции (вызов деструктора ~string()).
- Возвращаемая ссылка:
  - После возврата из функции ссылка указывает на уничтоженный объект.
  - Любое использование этой ссылки — UB (чтение, запись, вызов методов).

### 3. Возврат rvalue-ссылки (перемещение) 
```cpp
std::string&& getMovableString() {
    static std::string s = "Temporary";
    return std::move(s);
}
```
- Применение:
  - Явное перемещение ресурсов 
  - Move-семантика в STL: ```std::unique_ptr<int>&& getUniquePtr();```

### 4. Возврат через параметры (out-параметры)
```cpp
void getNumbers(int& outX, int& outY) {
    outX = 10; 
    outY = 20;
}
```
- Устаревший, но иногда полезный подход

### 5. Возврат структуры
```cpp
std::tuple<int, std::string> getData() {
    return {42, "Answer"};
}
```
#### Современное использование (C++17):
```cpp
auto [num, str] = getData(); // Structured bindings
```

### 6. Возврат умных указателей
```cpp
std::unique_ptr<Resource> createResource() {
    return std::make_unique<Resource>();
}
```
- Преимущества:
  - Безопасная передача владения
  - Используется в фабричных функциях

| Способ                | Владение ресурсами | Безопасность | Эффективность       |
|-----------------------|--------------------|--------------|---------------------|
| **По значению**       | Полное             | ✅           | Зависит от RVO      |
| **По ссылке**         | Отсутствует        | ⚠️          | ✅                 |
| **По rvalue-ссылке**  | Перемещаемое       | ✅           | ✅                 |
| **Через out-параметры** | Запутанное       | ❌           | ✅                 |
| **Структуры** | Полное             | ✅           | Зависит от RVO      |
| **Умные указатели**   | Явное              | ✅           | ✅                 |

## №21 Каков порядок вычисления выражений, передаваемых в качестве аргументов при вызове функции?

### Основное правило
- Порядок вычисления аргументов функции не определён стандартом (unspecified behavior).
Компилятор может вычислять их в любом порядке.
  ```cpp
   void foo(int a, int b) {}
   
   int i = 0;
   foo(i++, i++); // Неопределённое поведение!
   ```
- Результат зависит от компилятора: может быть foo(0, 1) или foo(1, 0).

### Исключения
- Полные выражения (full expressions) разделены точками следования (sequence points):
  ```cpp
  f(a(), b()); // a() и b() — отдельные полные выражения
  ```
- Точка следования — это моменты, когда все побочные эффекты предыдущих вычислений завершены (например, ;, &&, ||, ? :).

