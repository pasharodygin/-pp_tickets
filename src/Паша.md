# Билеты 55-64

## 55. Что делает препроцессор? 
> Препроцессор - это отдельный этап обработки исходного кода перед компиляцией. Он выполняет текстовые преобразования исходного кода на основе специальных директив.

**Основные характеристики:**
- Работает на текстовом уровне (не анализирует синтаксис C++)
- Выполняется до компиляции
- Обрабатывает директивы, начинающиеся с символа `#`

### Обработка директив (`#...`)
Препроцессор выполняет инструкции, начинающиеся с `#`:
- `#include` - вставляет содержимое файла (библиотеки или заголовочные файлы: `.h`)
- `#define` - создаёт макроподстановки
- `#ifdef`/`#ifndef` - условная компиляция
- `#pragma` - специфичные для компилятора инструкции

### Удаление комментариев и пробелов
- Удаляет `//` и `/* ... */` комментарии
- Сокращает лишние пробелы и табы

### Склейка строк через '\'
```cpp
#define LONG_MACRO "This is a very long macro that \
                    spans multiple lines"
```

- Препроцессор не знает `C++`-синтаксиса — он работает с текстом.
- Без препроцессора компилятор получил бы "сырой" код с директивами, которые он не понимает!

## 56. Что такое ODR?  

> One Definition Rule (ODR) - Правило Одного Определения

В любой единице трансляции допустимо только одно определение любой переменной, функции, типа класса, типа перечисления, концепта (начиная с C++20) или шаблона.

Одно и только одно определение каждой невстраиваемой функции или переменной, которая использует `odr`,должно присутствовать во всей программе.

### ODR-использование

- Объект ODR-используется, если его значение читается (если только это не константа с известным на момент компиляции значением), записывается, его адрес берётся или с ним связывается ссылка
- Функция ODR-используется, если она вызывается или её адрес берётся

### Пример нарушения ODR

```cpp
// file1.cpp
int helper() { return 1; }

// file2.cpp
int helper() { return 2; } // Ошибка линковки: multiple definition
```

### Исключения
- **Inline**-сущности могут определяться многократно
- Шаблоны (т.к. не являются готовым кодом, а лишь инструкцией для компилятора)

Нарушение ODR для классов/шаблонов часто приводит к трудноуловимым ошибкам, так как компилятор не всегда может их обнаружить.


## 57. В каких случаях допустимо размещать определение функции в заголовочном файле, а в каких - нет? 

## 58. Что такое предварительное объявление (forward declaration) и для каких элементов языка это актуально?  
## 59. Когда начнётся и когда закончится время жизни объекта с именем `a`: `void f(X a) {}`?  
- начнётся: с момента вызова функции `f`
- закончится: в конце функции `f`

Итого: `a` живёт, пока выполняется функция `f`.

## 60. Когда начнётся и когда закончится время жизни объекта доступного по указателю `pa`: `void f() { auto pa = new X; }`?  
- начнётся: когда создадим объект (т.е. new X)
- закончится: когда закончится программа (т.к. нет `delete`, мы потеряли указатель на объект (mem-leak))

## 61. В каком порядке будут созданы, а в каком разрушены объекты с именами `a` и `b`: `void f() { X a; { Y b; } }`?  
**Порядок:**
```
X constructed
Y constructed
Y destructed
X destructed
```
Программа для проверки:
```cpp
#include <iostream>

using namespace std;

struct Y {
    Y() { std::cout << "Y constructed\n"; }
    ~Y() { std::cout << "Y destructed\n"; }
};

struct X {
    X() { std::cout << "X constructed\n"; }
    ~X() { std::cout << "X destructed\n"; }
};

void foo() {
    X a;
    {Y b;}
}

int main() {
    foo();
    return 0;
}
```

## 62. Какие подобъекты будут присутствовать в объекте класса `X`: `struct X : Y, Z { W w; V v; };`, каков порядок их создания и разрушения?  

> В объекте класса X будут присутствовать следующие подобъекты:
1. Подобъект базового класса Y.
2. Подобъект базового класса Z.
3. Подобъект нестатического члена w типа W.
4. Подобъект нестатического члена v типа V.

**Разбор порядка:**
1) Создание:
- Y -> Z -> w -> v -> X

2) Разрушение (в обратном порядке):
- X -> v -> w -> Z -> Y

**Убедиться в этом можно, запустив нижеприложенную программу**
```cpp
#include <iostream>

struct Y {
    Y() { std::cout << "Y constructed\n"; }
    ~Y() { std::cout << "Y destructed\n"; }
};

struct Z {
    Z() { std::cout << "Z constructed\n"; }
    ~Z() { std::cout << "Z destructed\n"; }
};

struct W {
    W() { std::cout << "W constructed\n"; }
    ~W() { std::cout << "W destructed\n"; }
};

struct V {
    V() { std::cout << "V constructed\n"; }
    ~V() { std::cout << "V destructed\n"; }
};

struct X : Y, Z {
    W w;
    V v;

    X() { std::cout << "X constructed\n"; }
    ~X() { std::cout << "X destructed\n"; }
};

int main() {
    X x;
    return 0;
}
```

## 63. Что такое временный объект и чем ограничено его время жизни?  

## 64. Чем отличается инициализация по умолчанию для базовых и пользовательских типов (классов)? 

