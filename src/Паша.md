# Билеты 55-64

## 55. Что делает препроцессор? 
> Препроцессор - это отдельный этап обработки исходного кода перед компиляцией. Он выполняет текстовые преобразования исходного кода на основе специальных директив.

**Основные характеристики:**
- Работает на текстовом уровне (не анализирует синтаксис C++)
- Выполняется до компиляции
- Обрабатывает директивы, начинающиеся с символа `#`

### Обработка директив (`#...`)
Препроцессор выполняет инструкции, начинающиеся с `#`:
- `#include` - вставляет содержимое файла (библиотеки или заголовочные файлы: `.h`)
- `#define` - создаёт макроподстановки
- `#ifdef`/`#ifndef` - условная компиляция
- `#pragma` - специфичные для компилятора инструкции

### Удаление комментариев и пробелов
- Удаляет `//` и `/* ... */` комментарии
- Сокращает лишние пробелы и табы

### Склейка строк через '\'
```cpp
#define LONG_MACRO "This is a very long macro that \
                    spans multiple lines"
```

- Препроцессор не знает `C++`-синтаксиса — он работает с текстом.
- Без препроцессора компилятор получил бы "сырой" код с директивами, которые он не понимает!

## 56. Что такое ODR?  

> One Definition Rule (ODR) - Правило Одного Определения

В любой единице трансляции допустимо только одно определение любой переменной, функции, типа класса, типа перечисления, концепта (начиная с C++20) или шаблона.

Одно и только одно определение каждой невстраиваемой функции или переменной, которая использует `odr`,должно присутствовать во всей программе.

### ODR-использование

- Объект ODR-используется, если его значение читается (если только это не константа с известным на момент компиляции значением), записывается, его адрес берётся или с ним связывается ссылка
- Функция ODR-используется, если она вызывается или её адрес берётся

### Пример нарушения ODR

```cpp
// file1.cpp
int helper() { return 1; }

// file2.cpp
int helper() { return 2; } // Ошибка линковки: multiple definition
```

### Исключения
- **Inline**-сущности могут определяться многократно
- Шаблоны (т.к. не являются готовым кодом, а лишь инструкцией для компилятора)

Нарушение ODR для классов/шаблонов часто приводит к трудноуловимым ошибкам, так как компилятор не всегда может их обнаружить.


## 57. В каких случаях допустимо размещать определение функции в заголовочном файле, а в каких - нет? 

## 58. Что такое предварительное объявление (forward declaration) и для каких элементов языка это актуально?  
## 59. Когда начнётся и когда закончится время жизни объекта с именем `a`: `void f(X a) {}`?  
- начнётся: с момента вызова функции `f`
- закончится: в конце функции `f`

Итого: `a` живёт, пока выполняется функция `f`.

## 60. Когда начнётся и когда закончится время жизни объекта доступного по указателю `pa`: `void f() { auto pa = new X; }`?  
- начнётся: когда создадим объект (т.е. new X)
- закончится: когда закончится программа (т.к. нет `delete`, мы потеряли указатель на объект (mem-leak))

## 61. В каком порядке будут созданы, а в каком разрушены объекты с именами `a` и `b`: `void f() { X a; { Y b; } }`?  
**Порядок:**
```
X constructed
Y constructed
Y destructed
X destructed
```
Программа для проверки:
```cpp
#include <iostream>

using namespace std;

struct Y {
    Y() { std::cout << "Y constructed\n"; }
    ~Y() { std::cout << "Y destructed\n"; }
};

struct X {
    X() { std::cout << "X constructed\n"; }
    ~X() { std::cout << "X destructed\n"; }
};

void foo() {
    X a;
    {Y b;}
}

int main() {
    foo();
    return 0;
}
```

## 62. Какие подобъекты будут присутствовать в объекте класса `X`: `struct X : Y, Z { W w; V v; };`, каков порядок их создания и разрушения?  

**В объекте класса X будут присутствовать следующие подобъекты:**
1. Подобъект базового класса Y.
2. Подобъект базового класса Z.
3. Подобъект нестатического члена w типа W.
4. Подобъект нестатического члена v типа V.

**Разбор порядка:**
1) Создание:
- Y -> Z -> w -> v -> X

2) Разрушение (в обратном порядке):
- X -> v -> w -> Z -> Y

**Убедиться в этом можно, запустив нижеприложенную программу**
```cpp
#include <iostream>

struct Y {
    Y() { std::cout << "Y constructed\n"; }
    ~Y() { std::cout << "Y destructed\n"; }
};

struct Z {
    Z() { std::cout << "Z constructed\n"; }
    ~Z() { std::cout << "Z destructed\n"; }
};

struct W {
    W() { std::cout << "W constructed\n"; }
    ~W() { std::cout << "W destructed\n"; }
};

struct V {
    V() { std::cout << "V constructed\n"; }
    ~V() { std::cout << "V destructed\n"; }
};

struct X : Y, Z {
    W w;
    V v;

    X() { std::cout << "X constructed\n"; }
    ~X() { std::cout << "X destructed\n"; }
};

int main() {
    X x;
    return 0;
}
```

## 63. Что такое временный объект и чем ограничено его время жизни?  

### Временные объекты и их время жизни

> **Временный объект** — это объект, который создаётся на месте и существует только в рамках одного выражения.  

#### **Когда создаются временные объекты?**  
1. При возвращении значения из функции без привязки к переменной.  
2. При передаче результата выражения в функцию.  
3. При создании анонимного объекта (`X()` вместо `X obj;`).  

#### **Как долго живёт временный объект?**  
- По умолчанию **до конца выражения**, в котором он создан.  
- Если временный объект привязывается к `const&`, то **живет до конца области видимости ссылки**.  

#### **Примеры:**  
```cpp
#include <iostream>

struct X {
    X() { std::cout << "Created X\n"; }
    ~X() { std::cout << "Deleted X\n"; }
};

struct Y {
    Y() { std::cout << "Created Y\n"; }
    ~Y() { std::cout << "Deleted Y\n"; }
};

X fx() { return X(); } // Создаётся временный объект
Y fy() { return Y(); } // Создаётся временный объект

int main() {
    const Y& xr = fy(); // Здесь объект будет жить до конца main
    fx(); // Временный объект уничтожится сразу после вызова f()
}
```

`Будет выведено` (поч? см. комменты кода выше):
```
Created Y
Created X
Deleted X
Deleted Y
```

**Ошибка использования временного объекта:**
```cpp
int& f(int& a) { 
    return a; 
}

int main(int argc, char** argv) {
    return 11 + f(argc * 2); // Error: передаётся временное значение, а ожидается ссылка
}
```

### Итог:
1. Временный объект живёт до конца выражения, если не привязан к const&.

2. Использование временных объектов в функциях, ожидающих ссылку &, может привести к недействительным ссылкам и ошибкам.

## 64. Чем отличается инициализация по умолчанию для базовых и пользовательских типов (классов)? 

**Базовые vs пользовательские**
> Базовые
- Базовые типы не содержат методов, конструктора или деструктора и хранят только данные.
- Базовый тип — это встроенный тип данных, без методов (int, double, char и т. д.), у них фиксированное поведение.
- Базовый класс — это **именно** родительский класс, от которого можно наследоваться.
> Пользовательские
- Пользовательский класс — это **любой** класс, который создаёт программист, независимо от его роли.
- Пользовательский тип — это тип данных, определённый программистом (поведение можно менять).

### Различия инициализации (примеры)

**Базированный нормис**

```cpp
#include <iostream>

int y; // 0 (т.к. глобально)

int main() {
    int x; // мусор - случайное число (т.к. локально)
    std::cout << y << ' ' << x;
}
```
*P.S. Clion умный, поэтому запустить можно [здесь](https://www.online-cpp.com/)*

**Конструктор по умолчанию у пользовательского типа (класса)**

```cpp
#include <iostream>

class Car {
public:
    int speed; // Поле остается неинициализированным
    Car() { speed = 100; } // Конструктор по умолчанию
};

int main() {
    Car myCar; 
    std::cout << myCar.speed << std::endl; // Выведет 100
}
```

**Пример с мусором**

```cpp
class Bike {
public:
    int speed; // Неинициализированная переменная
};

int main() {
    Bike myBike;
    std::cout << myBike.speed << std::endl; // Мусорное значение
}
```

### Вывод
Пользовательские типы (классы) автоматически вызывают конструктор по умолчанию, если он есть, инициализируя поля. Если конструктора нет, поведение такое же, как у базовых типов.

