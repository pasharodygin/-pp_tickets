# Билеты 55-64

## 55. Что делает препроцессор? 
> Препроцессор - это отдельный этап обработки исходного кода перед компиляцией. Он выполняет текстовые преобразования исходного кода на основе специальных директив.

**Основные характеристики:**
- Работает на текстовом уровне (не анализирует синтаксис C++)
- Выполняется до компиляции
- Обрабатывает директивы, начинающиеся с символа `#`

### Обработка директив (`#...`)
Препроцессор выполняет инструкции, начинающиеся с `#`:
- `#include` - вставляет содержимое файла (библиотеки или заголовочные файлы: `.h`)
- `#define` - создаёт макроподстановки
- `#ifdef`/`#ifndef` - условная компиляция
- `#pragma` - специфичные для компилятора инструкции

### Удаление комментариев и пробелов
- Удаляет `//` и `/* ... */` комментарии
- Сокращает лишние пробелы и табы

### Склейка строк через '\'
```cpp
#define LONG_MACRO "This is a very long macro that \
                    spans multiple lines"
```

- Препроцессор не знает `C++`-синтаксиса — он работает с текстом.
- Без препроцессора компилятор получил бы "сырой" код с директивами, которые он не понимает!

## 56. Что такое ODR?  

> One Definition Rule (ODR) - Правило Одного Определения

В любой единице трансляции допустимо только одно определение любой переменной, функции, типа класса, типа перечисления, концепта (начиная с C++20) или шаблона.

Одно и только одно определение каждой невстраиваемой функции или переменной, которая использует `odr`,должно присутствовать во всей программе.

### ODR-использование

- Объект ODR-используется, если его значение читается (если только это не константа с известным на момент компиляции значением), записывается, его адрес берётся или с ним связывается ссылка
- Функция ODR-используется, если она вызывается или её адрес берётся

### Пример нарушения ODR

```cpp
// file1.cpp
int helper() { return 1; }

// file2.cpp
int helper() { return 2; } // Ошибка линковки: multiple definition
```

### Исключения
- **Inline**-сущности могут определяться многократно
- Шаблоны (т.к. не являются готовым кодом, а лишь инструкцией для компилятора)

Нарушение ODR для классов/шаблонов часто приводит к трудноуловимым ошибкам, так как компилятор не всегда может их обнаружить.


## 57. В каких случаях допустимо размещать определение функции в заголовочном файле, а в каких - нет?  
## 58. Что такое предварительное объявление (forward declaration) и для каких элементов языка это актуально?  
## 59. Когда начнётся и когда закончится время жизни объекта с именем `a`: `void f(X a) {}`?  
## 60. Когда начнётся и когда закончится время жизни объекта доступного по указателю `pa`: `void f() { auto pa = new X; }`?  
## 61. В каком порядке будут созданы, а в каком разрушены объекты с именами `a` и `b`: `void f() { X a; { Y b; } }`?  
## 62. Какие подобъекты будут присутствовать в объекте класса `X`: `struct X : Y, Z { W w; V v; };`, каков порядок их создания и разрушения?  
## 63. Что такое временный объект и чем ограничено его время жизни?  
## 64. Чем отличается инициализация по умолчанию для базовых и пользовательских типов (классов)? 