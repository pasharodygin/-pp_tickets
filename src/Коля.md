# Билеты 34-43

## 34. Чем инициализируются переменная типа bool по умолчанию?

Локальные переменные (автоматическая область видимости) не инициализируются по умолчанию, то есть их значение неопределено, если их не инициализировать явно.
Глобальные переменные, статические переменные и члены классов, имеющие статическую длительность хранения, инициализируются нулём, что для `bool` означает значение `false`.

## 35. Какие варианты приведения типов по иерархии наследования существуют и чем отличаются?
### Upcasting (приведение к базовому типу)
Преобразование указателя или ссылки на производный класс к указателю/ссылке на базовый класс. Это безопасное преобразование, часто выполняется неявно, так как производный всегда является базовым.

### Downcasting (приведение к производному типу)
Преобразование указателя или ссылки базового класса к указателю/ссылке на производный класс. Это преобразование может быть небезопасным, если объект на самом деле не является экземпляром производного класса.

### static_cast
Может использоваться для downcasting, но не выполняет проверку во время выполнения. Его следует применять, если вы уверены в типе объекта.

### dynamic_cast
Выполняет проверку типа во время выполнения и возвращает nullptr (для указателей) или генерирует исключение (для ссылок) при неудачном приведении. Его используют для безопасного downcasting, когда базовый класс имеет хотя бы одну виртуальную функцию.

### Другие виды приведения

### const_cast
Удаляет или добавляет квалификатор const (или volatile).

### reinterpret_cast
Выполняет низкоуровневое преобразование между указателями, не связанными с наследованием (небезопасное, платформозависимое).



## 36. В чем разница между enum и enum class, зачем нужны последние?

В C++ существуют два типа перечислений: классические enum (обычные или "неограниченные" перечисления) и enum class (ограниченные перечисления, введенные в C++11). Вот их ключевые различия и преимущества enum class:

### Основные различия
#### Область видимости (scoping):
`enum`: Имена перечислителей находятся в той же области видимости, что и само перечисление (может приводить к конфликтам имен)

```
enum Color { RED, GREEN, BLUE };
enum TrafficLight { RED, YELLOW, GREEN }; // Ошибка: повторное определение
```

`enum class`: Имена перечислителей находятся внутри области видимости перечисления

```
enum class Color { RED, GREEN, BLUE };
enum class TrafficLight { RED, YELLOW, GREEN }; // OK
```

##### Неявное преобразование типов:
`enum`: Неявно преобразуется в целочисленные типы

`enum class`: Нет неявного преобразования в целочисленные типы

##### Тип перечисления:
`enum`: Базовый тип не фиксирован (компилятор выбирает)
```
enum class SmallEnum : uint8_t { VALUE1, VALUE2 }; // 8 бит
```
`enum class`: Можно явно указать базовый тип

Преимущества enum class:
Предотвращение конфликтов имен

Типобезопасность

Явное указание размера

```
enum class NetworkPacketType : uint16_t {
    DATA = 0x0102,
    ACK  = 0x0203
};
```

`enum class`: Всегда, когда возможен C++11 и выше (рекомендуемый выбор)

### Вывод:
`enum class` обеспечивают:
- Лучшую инкапсуляцию (избегают "загрязнения" пространства имен)
- Повышенную типобезопасность
- Возможность явного контроля размера
- Более чистый и поддерживаемый код


## 37. Есть ли разница между структурой struct и классом class?

#### Различие между структурами и классами
- struct – по умолчанию, public права доступа к членам, public
наследование
- class – по умолчанию, private права доступа к членам, private
наследование

#### Стилистические различия
Хотя функционально они почти идентичны, сложились соглашения об использовании:
`class` используют для:
- Сложных объектов с инкапсуляцией
- Когда нужны private-члены и методы
- Для реализации ООП (наследование, полиморфизм)

`struct` используют для:
- Простых контейнеров данных (POD — Plain Old Data)
- Когда все члены должны быть публичными
- Для совместимости с C


## 38. Какие есть спецификаторы прав доступа в C++ и в чем отличие между ними?
В C++ существуют три спецификатора доступа, которые определяют видимость членов класса (полей и методов) и базовых классов:
- `public`
- `private`
- `protected`

### `public`
-**Доступ**: Из любого места программы
-**Для членов класса**:
```
class MyClass {
public:
    int publicVar;  // Доступно отовсюду
    void publicMethod() {}
};
```
-**Для наследования:**
```
class Derived : public Base {}; // Публичное наследование
```

### `protected` (ограниченный доступ)
**Доступ:**
- Из методов самого класса
- Из методов производных классов
- Недоступно извне иерархии наследования

### `private` (максимально закрытый)
**Доступ:** Только из методов самого класса

### Пример
```
class BankAccount {
private:          // Скрытая реализация
    double balance;

protected:        // Для наследников
    void logTransaction() {}

public:           // Интерфейс
    void deposit(double amount) {
        balance += amount;
        logTransaction();
    }
};

class SavingsAccount : public BankAccount {
public:
    void addInterest() {
        // balance -= 10;  // Ошибка: private
        logTransaction();  // OK: protected
    }
};

int main() {
    SavingsAccount acc;
    acc.deposit(1000);     // OK: public
    // acc.logTransaction(); // Ошибка: protected
}
```
  
### Когда что использовать:
- `public`: Интерфейс класса (что могут использовать все)
- `protected`: Для расширения класса в наследниках
- `private`: Внутренняя реализация (инкапсуляция)
  
Эти спецификаторы — основа инкапсуляции в C++, позволяющая скрывать детали реализации и предоставлять четкие интерфейсы.













