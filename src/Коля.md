# Билеты 34-43

## 34. Чем инициализируются переменная типа bool по умолчанию?

Локальные переменные (автоматическая область видимости) не инициализируются по умолчанию, то есть их значение неопределено, если их не инициализировать явно.
Глобальные переменные, статические переменные и члены классов, имеющие статическую длительность хранения, инициализируются нулём, что для `bool` означает значение `false`.

## 35. Какие варианты приведения типов по иерархии наследования существуют и чем отличаются?
### Upcasting (приведение к базовому типу)
Преобразование указателя или ссылки на производный класс к указателю/ссылке на базовый класс. Это безопасное преобразование, часто выполняется неявно, так как производный всегда является базовым.

### Downcasting (приведение к производному типу)
Преобразование указателя или ссылки базового класса к указателю/ссылке на производный класс. Это преобразование может быть небезопасным, если объект на самом деле не является экземпляром производного класса.

### static_cast
Может использоваться для downcasting, но не выполняет проверку во время выполнения. Его следует применять, если вы уверены в типе объекта.

### dynamic_cast
Выполняет проверку типа во время выполнения и возвращает nullptr (для указателей) или генерирует исключение (для ссылок) при неудачном приведении. Его используют для безопасного downcasting, когда базовый класс имеет хотя бы одну виртуальную функцию.

### Другие виды приведения

### const_cast
Удаляет или добавляет квалификатор const (или volatile).

### reinterpret_cast
Выполняет низкоуровневое преобразование между указателями, не связанными с наследованием (небезопасное, платформозависимое).



## 36. В чем разница между enum и enum class, зачем нужны последние?

В C++ существуют два типа перечислений: классические enum (обычные или "неограниченные" перечисления) и enum class (ограниченные перечисления, введенные в C++11). Вот их ключевые различия и преимущества enum class:

### Основные различия
#### Область видимости (scoping):
`enum`: Имена перечислителей находятся в той же области видимости, что и само перечисление (может приводить к конфликтам имен)
`
enum Color { RED, GREEN, BLUE };
enum TrafficLight { RED, YELLOW, GREEN }; // Ошибка: повторное определение
`

`

`enum class`: Имена перечислителей находятся внутри области видимости перечисления

`
enum class Color { RED, GREEN, BLUE };
`
`
enum class TrafficLight { RED, YELLOW, GREEN }; // OK
`

##### Неявное преобразование типов:
`enum`: Неявно преобразуется в целочисленные типы

`enum class`: Нет неявного преобразования в целочисленные типы

##### Тип перечисления:
`enum`: Базовый тип не фиксирован (компилятор выбирает)

`enum class`: Можно явно указать базовый тип

Преимущества enum class:
Предотвращение конфликтов имен

Типобезопасность

Явное указание размера

```
enum class NetworkPacketType : uint16_t {
    DATA = 0x0102,
    ACK  = 0x0203
};
```

`enum class`: Всегда, когда возможен C++11 и выше (рекомендуемый выбор)

### Вывод:
`enum class` обеспечивают:
- Лучшую инкапсуляцию (избегают "загрязнения" пространства имен)
- Повышенную типобезопасность
- Возможность явного контроля размера
- Более чистый и поддерживаемый код
















